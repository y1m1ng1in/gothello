import copy
import random

from board import (Board, Move, ILLEGAL_MOVE, CONTINUE, 
  GAME_OVER, PLAYER_BLACK, PLAYER_WHITE)

from minimax_utility import MinimaxUtility


inf = 999999

ITER_DEEPENING_EXCEPTION = 1


class TerminationException(Exception):

  def __init__(self, 
               code=ITER_DEEPENING_EXCEPTION, 
               msg="iterative deepening resource exhausted"):
    self.code = code
    self.msg = msg


class AlphaBetaPruning(MinimaxUtility):

  def __init__(self,
               side,
               depth=3,
               move_ordering=False,
               selective_search=False, 
               eval_method="number",
               scoring={
                 'stone': 1,
                 'black connection': 1,
                 'white connection': 2
               },
               dynamic_eval=False,
               auto_adjust_scoring={
                 'stone': 1,
                 'black connection': 3,
                 'white connection': 3,
                 'black eye': 1,
                 'white eye': 1,
                 'serial': 10
               },
               print_leaves=False, 
               print_stats=False):
          
    super().__init__(side, 
                     eval_method=eval_method, 
                     scoring=scoring, 
                     dynamic_eval=dynamic_eval,
                     auto_adjust_scoring=auto_adjust_scoring)

    self.depth = depth

    self.print_leaves = print_leaves
    self.print_stats = print_stats
    
    # test-purpse -- how many states have been visited
    self.nvisited = 0 
    self.npruned = 0

    # recorded move path during one decision
    self.move_path = []

    # whether re-order moves generated by genMoves()
    self.reorder_move = move_ordering

    # whether ignore move that is near opponent's eye
    self.selective_search = selective_search

  def decision(self):
    self.nvisited, self.npruned, self.move_path = 0, 0, []
    _, move = self.__max_value(self, self.depth, -inf, inf)
    print("number of states visited: ", self.nvisited - 1)
    print("number of returned by pruning: ", self.npruned)
    print("move path: ", [[str(m) for m in ms] for ms in self.move_path])
    return move

  def __max_value(self, board, depth, alpha, beta):
    self.nvisited += 1
    value, moves = self.__terminal_test(board, depth)
    if value != None and not moves:
      return value, None 

    assert value == None and moves
    
    value = -inf
    move_candidates = []  # my move candidates that have same eval value 
    opp_move_candidates = set()  # opponent move candidiates that have same eval value

    for move in moves:
      b = AlphaBetaPruning.board_after_moving(board, move)
      opp_value, opp_move = self.__min_value(b, depth - 1, alpha, beta)
      if opp_value > value:
        value = opp_value
        move_candidates = [move]
        opp_move_candidates = set([opp_move])
      elif opp_value == value:
        move_candidates.append(move)
        opp_move_candidates.add(opp_move)
      if value >= beta:
        self.npruned += 1
        self.move_path.append(list(opp_move_candidates))
        self.move_path.append(move_candidates) 
        return value, AlphaBetaPruning.random_pick_move(move_candidates)
      alpha = max(alpha, value)

    self.move_path.append(list(opp_move_candidates))
    self.move_path.append(move_candidates)
    return (value, AlphaBetaPruning.random_pick_move(move_candidates),
            move_candidates, opp_move_candidates)

  def __min_value(self, board, depth, alpha, beta):
    self.nvisited += 1
    value, moves = self.__terminal_test(board, depth)
    if value and not moves:
      return value, None 
    
    assert not value and moves
    
    value = inf
    move_candidates = []

    for move in moves:
      b = AlphaBetaPruning.board_after_moving(board, move)
      my_value, _ = self.__max_value(b, depth - 1, alpha, beta)
      if my_value < value:
        value = my_value
        move_candidates = [move]
      elif my_value == value:
        move_candidates.append(move)
      if value <= alpha:
        self.npruned += 1
        return value, AlphaBetaPruning.random_pick_move(move_candidates)
      beta = min(beta, value)

    return value, AlphaBetaPruning.random_pick_move(move_candidates)

  def __terminal_test(self, board, depth):
    """ 
    Decide whether maximum depth is reached, and there is no possible move 
    at current state. And indicate whether we should continue searching 
    by returning a list of moves or returning None
    :return: evaluated value, None    if there is at terminal state
             None, a list of moves    if there isn't at terminal state
    """
    if depth <= 0:
      return self.__eval(board), None
    moves = self.__generate_moves(board)
    if not moves:
      return self.__eval(board), None
    return None, moves

  def __eval(self, board):
    """
    Evaluate a board based on serial number of server side, and whether 
    dynamic_eval flag is enabled. 
    """
    if self.dynamic_eval and board.serial >= board.eval_adjusted['serial']:
      return board.evaluate(adjust=True)
    return board.evaluate()

  def __generate_moves(self, board):
    moves = board.gen_moves()
    #if self.reorder_move:
    #  moves = board.move_ordering(moves)
    #if self.selective_search:
    #  moves, avoided = board.avoid_opponent_eye(moves)
    #return moves + avoided
    return moves

  @staticmethod
  def random_pick_move(moves):
    assert moves
    pick_move = random.randint(0, len(moves) - 1) 
    return moves[pick_move]

  @staticmethod
  def board_after_moving(board, move):
    """
    Deepcopy a board(i.e. AlphaBetaPruning object), and try move
    :param board: AlphaBetaPruning object
    :param move: Move object
    :return: AlphaBetaPruning object after trying move
    """
    b = copy.deepcopy(board)
    result = b.try_move(move)
    if result == ILLEGAL_MOVE:
      raise Exception("illegal move in minimax")
    b.update_connected_stones()
    return b

  def __iter_deepening(self):
    """
    First, search 1 ply deep and record the best path of moves.
    Then search 1 ply deeper, but use the recorded path to inform 
    move ordering.
    """
    pass